 /*==========================
   ■■■ 클래스 고급 ■■■
============================*/

// 상속(Inheritance)
/*
○ 상속(Inheritance)이란
   새로 설계(생성)하고자 하는 클래스가
   이미 설계되어 있는 다른 클래스의 기능과 중복되는 경우
   이미 설계된 클래스의 일부분이나 전체 구조를 공유할 수 있도록 하는 기능을 의미한다.

   즉, 상속은 객체를 좀 더 쉽게 만들 수 있는
   고수준의 재사용성(reusability)을 확보하고 
   객체간의 관계를 구성함으로써
   객체 지향의 또 다른 특징인 『다형성』의 문법적 토대가 된다.

   상속은 기존 프로그램의 클래스 내용을 공유함으로써
   중복된 코드들을 재작성할 필요 없이
   반복적이고 세부적인 작업을 처리하지 않기 때문에
   프로그램을 작성하는 시간을 절약할 수 있고
   유지보수를 편리하게 할 수 있으며,
   프로그램의 길이도 짧아지게 된다.

   또한, 이미 작성된 프로그램들은 앞서 테스트되었기 때문에
   오류를 줄일 수 있어 현재 작성 중인 프로그램에만 전념할 수 있다.


※ 주의할 점 ※

   자바는 『다.중.상.속.』을 지원하지 않기 때문에
   두 개 이상의 클래스로부터 상속받을 수 없다.

   자바는 『단.일.상.속.』만 지원한다.
   => 먼저 나온 객체지향 언어들은 다 다중상속임
      자바가 나중에 나오다보니까 다중상속이 문제인거 같으니 뺌
*/

// 상위 클래스 == 부모 클래스 == Super 클래스	→ 물려주는 클래스
// 하위 클래스 == 자식 클래스 ==   Sub 클래스	→ 상속받는 클래스

// 부모 클래스
class SuperTest113
{
	protected double area;

	// 부모 클래스의 생성자  ==> ※ 생성자는 상속 대상에서 제외된다.
	SuperTest113()
	{
		System.out.println("Super Class...");
	}
		
	void write(String title)
	{
		System.out.println(title + " - " + area);
	}
}

// 자식 클래스
// 자바는 단일 상속만 지원되며, 다중 상속은 허용하지 않는다.
public class Test113 extends SuperTest113	//, SuperTest114, SuperTest115
{
	/*
	extends SuperTest113  하는 순간, 내부적으로는 어떤 일이 벌어지느냐면,,,
	
	↓ Step 1) 부모 클래스에 있는 내용 싹 다 아래에 복붙함
		       부모 클래스에 있는 코드 아래로 내려오는 효과
				- 자식 클래스에서는 area 변수 write() 메서드 작성한 적도 없지만,
		          물려받아서 사용 가능해짐!

	protected double area;		//-- protected라 물려받는 거 OK!
								//---->> 부모로부터 물려받은 area

	// 부모 클래스의 생성자
	// ※ 생성자는 상속 대상에서 제외된다.
	//---> 부모 클래스가 다 물려주지만,,!! 생성자는 물려주지 않음!!!! 상속 X
	SuperTest113()				
	{
		System.out.println("Super Class...");
	}
		
	void write(String title)	//-- default라 상속받은 클래스에서 접근 못하지만
								//   SuperTest113과 Test113 동일 패키지 내에 있기 때문에
								//   접근 가능함
								//-- 둘이 서로 다른 패키지에 있는 상황이라면,
								//   이거는 접근 못 함! 물려받는거 XX
	{
		System.out.println(title + " - " + area);
	}
	*/

	//double area = 10.1234;		//---->> 원래 내가(자식이) 갖고 있던 area
		// 부모로부터 물려받은 area와 내가 갖고 있는 area 변수명 같지만 허용됨
		// 부모의 area 와 자식의 area 구분 가능함

	// 자식 클래스의 생성자
	Test113()
	{
		// 내가   내 생성자 호출할 때는 ==> this();
		//	    부모 생성자 호출할 때는 ==> super();
				//--- 코드에서 super() 만나면, 걔가 포함된 클래스로 가보기
				//	  그럼 100% extends 어쩌고 써있음
				//	  extends 뒤에 써 있는 그 클래스 이름으로 치환해서 사용하기


		//SuperTest113();	==> 우리 눈에 보이지는 않지만 작업 이루어짐
			//	===> ****** !!! 그리고 이렇게 클래스 이름으로 사용 불가 !!!! ********


		// 부모 클래스 생성자 호출
		//super();
		//-- 눈에 보이지 않지만 있음

		// ※ 생성자 내부에서 또 다른 생성자를 호출하는 문법
		//	--> 가능하다. 단, 생성자 내부에서 가장 먼저 실행되어야 한다.

		//Test113(10.5);	//--(X) 클래스이름 사용 불가!! this() 사용하기!!
		//this(10.5);		//--(O)	
							//	코드에서 this 만나면, 
							//	걔가 포함된 클래스로 가서 그 이름으로 치환해서 사용하기

		System.out.println("Sub Class...");
	}

	Test113(double x)
	{
		area = x;
	}

	public void actionCircle()
	{
		int r = 10;
		area = r * r * 3.141592;		// area check~!!! (부모area? 자식area?)
		write("원");					
		//-- 자식에게는 원래 write() 없지만, 가지고 있는 것처럼 호출해서 사용가능
	}

	public void actionRect()
	{
		int w = 20, h = 5;
		area = w * h;					// area check~!!! (부모area? 자식area?)
		write("사각형");
	}

	public static void main(String[] args)
	{
		// Test113 클래스(자식) 기반 인스턴스 생성
		Test113 ob = new Test113();
		//--==> Super Class...		==> 부모 생성자도 같이 호출됨
		//      Sub Class...	
		//==> Test113 ob = new Test113(); 수행하게 되는 순간
		// Test113 메모리에 퍼올려짐 
		//	=> 자식클래스의 생성자 호출되면서 메모리 할당받고, 변수 초기화 등 업무 함
		// 부모클래스도 내꺼처럼 사용하려면, 부모클래스도 메모리에 퍼올려져야함
		// 그러면서 부모클래스의 생성자도 호출됨
		// =====> ** 자식 클래스 생성자가 부모 클래스의 생성자 호출함

		// 그런데 왜 !! 부모 클래스 먼저 출력되고, 자식 클래스가 나중에 실행돼?
		// ===> 상속이랑 상관없이
		//		생성자에서 또 다른 생성자의 호출은 가능하다.
		//		하지만...! ***** 생성자 내부에서 가장 먼저 실행되어야 한다. *****

		ob.actionCircle();	//--==> 원 - 314.1592
			// 자식이 갖고 있는 area는 주석처리 한 상태
			// 보이는 area는 부모의 area 뿐
			// 그럼 부모로 물려받은 area, write() 사용
			// 부모 area에 결과값 담아서 그 area 출력함
		
		ob.actionRect();	//--==> 사각형 - 100.0
	}
}

// 실행 결과
/*

*/