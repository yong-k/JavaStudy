 /*=================================
   ■■■ 클래스와 인스턴스 ■■■
===================================*/

// 생성자(Constructor)와 초기화 블럭(Initialized Block)

public class Test080
{
	/*
	int n;
	int m;

	n = 100;
	m = 200;
	// 에러 남
	// **클래스에 직접 대입, 산술, 관계 연산 불가
	*/
	/*
	int n = 100;
	int m = 200;
	// 이거는 됨
	// 클래스에서 선언과 동시에 초기화 하는 건 가능함
	// 선언을 해두고 그걸 따로 연산하는 건 불가
	*/

	int n;
	int m;
	
	// 초기화 블럭(Initialized Block)
	{
		n = 20;
		m = 40;
		System.out.println("초기화 블럭 실행...");
	}
	// {} 치면 가능
	// 클래스 영역에서 하려고 하면 에러발생하지만, 
	// 별도의 블럭 안에서 연산하니까 됨
	// {} => 초기화 블럭

	// 생성자(Constructor)
	// → 초기화 블럭이 코드를 먼저 수행했다 하더라도
	//	  최종적으로 해당 멤버들의 초기화 값을 결정하게 되는 개념
	Test080()
	{
		n = 100;
		m = 200;
		System.out.println("생성자 실행...");
	}
	// 생성자-초기화블럭 같이 있으면 항상 초기화블럭이 먼저 실행됨
	// 순서 바꾼다고 바뀌는 거 아님 -> 순서대로 실행되는 게 아니므로
	// 그럼, 초기화블럭이 먼저 실행되니까, 초기화블럭이 더 중요한 거 아님???
	// -> 라고 생각하는 사람들 많은데, NO!
	// 생성자가 중요하기 때문에 나중에 등장하는 거임
	// 초기화 블럭이 뭐라고 해놨던지, 생성자가 등장하면서 덮어쓰기로 정리해버림
	// => 나중에 실행되는 건 먼저 실행된 걸 덮어쓰기 해버림!!!
	// 생성자 안에서 또 다른 생성자 생성할 때도,
	// 제일 먼저 불러서 그 내용으로 정리한 다음, 
	// 원래 생성자에서 본인의 내용으로 덮어쓰기 할 거 하면서 최종적으로 내용 정리함

	Test080(int n, int m)
	{
		this.n = n;
		this.m = m;
		System.out.println("매개변수 있는 생성자 실행...");
	}

	// 멤버 출력 메소드 정의
	void write()
	{
		System.out.println("n : "  + n + ", m : " + m);
	}

	public static void main(String[] args)
	{
		Test080 ob1 = new Test080();	
		ob1.write();

		Test080 ob2 = new Test080(1234,5678);
		ob2.write();
	}
}

// 실행 결과
/*
초기화 블럭 실행...
생성자 실행...
n : 100, m : 200
초기화 블럭 실행...
매개변수 있는 생성자 실행...
n : 1234, m : 5678
계속하려면 아무 키나 누르십시오 . . .
*/