 /*==========================
   ■■■ 클래스 고급 ■■■
============================*/

// 상속 관계에 있는 클래스들 간의 캐스팅
// 업 캐스팅, 다운 캐스팅

// super class, 부모 클래스, 상위 클래스
class SuperTest118
{
	public int a = 10, b = 20;

	public void write()
	{
		System.out.println("슈퍼 클래스 write() 메소드...");
	}

	public int hap()
	{
		return a + b;
	}
}

// sub class, 자식 클래스, 하위 클래스
class SubTest118 extends SuperTest118
{
	public int b = 100, c = 200;

	@Override
	public int hap()
	{
		return a + b + c;
	}

	public void print()
	{
		System.out.println("서브 클래스 print() 메소드...");
	}
}

// main() 메소드를 포함하는 외부의 다른 클래스
public class Test118
{
	public static void main(String[] args)
	{
		SubTest118 ob1 = new SubTest118();

		System.out.println("ob1.b : " + ob1.b);	// ob1.b = 100
		
		// ○ 업 캐스팅
		//==> 실제로 만들어진 건, 하위객체
		//    그런데 상위 객체로 캐스팅해서 사용하는 것
		//SuperTest118 ob2;	// 문제 없음
		SuperTest118 ob2 = ob1;
		//-- 『SuperTest118 ob2 = (SuperTest118)ob1;』과 동일한 코드

		/*
		학생 정용 = new 정용();
		인간 행인 = 정용;			// 『인간 행인 = (인간)정용;』과 동일한 코드

		※ 학생도 인간
		※ class 인간		class 학생 extends 인간
		   {				{ 
		   }				}

		   비교
		   byte a = 10;
		   short b = a;				// 『short b = (short)a;』과 동일한 코드
		*/

		System.out.println("ob2.b : " + ob2.b);	// ob2.b = 20
		//-- *** 변수는 객체별로 따로 할당되므로
		//       변수 b는 ob2의 변수이다.

		System.out.println("합    : " + ob2.hap());	// 합    : 310
		// 내 예측: 230 ==> (x),,,,
		// 생성된 건 자식이었지만, 부모타입으로 업캐스팅해서
		// 부모.b 하니까 부모의 b로 접근됐음
		// 그런데 메소드는 부모꺼 물려받아서 Overriding 하게 되면 덮어쓰기 됨
		// 부모껄로 돌아갈 수 없음
		// 그래서 호출되는 hap() 메소드는 자식의 hap()
		// 자식.hap()입장에서 a = 10(자기꺼 없으니 부모꺼), 
		//		b = 100, c = 200 => 자기꺼만 보이니까 자기껄로
		//-- hap() 메소드는 오버라이딩(Overriding) 되어 있고
		//	 ob2 는 ob1 을 업캐스팅한 상태의 객체이므로
		//	 『SuperTest118』의 hap() 메소드를 호출하는 것이 아니라
		//	 『SubTest118』에서 재정의한 hap() 메소드를 호출하게 된다.
		//	 즉, 메소드는 업캐스팅이 되더라도
		//	 재정의(덮어쓰기)한 이상... 원래의 기능으로 되돌릴 수 없다.
	
		ob2.write();			// 슈퍼 클래스 write() 메소드...

		//ob2.print();	
		//--==> 에러 발생(컴파일 에러) error: cannot find symbol
		// 현재 부모객체임
		// 부모입장에서는 자식이 print()라는 메소드 갖고 있는 것도 모름

		// ○ 다운 캐스팅
		((SubTest118)ob2).print();	// 서브 클래스 print() 메소드...
		
		// ※ 추가 관찰 -----------------------------------------------------------
		//	  다운 캐스팅 가능 여부

		SuperTest118 ob3 = new SuperTest118();
		SubTest118 ob4 = new SubTest118();

		//System.out.println(ob3.c);	
		//--==> 에러 발생 (컴파일 에러)  error: cannot find symbol
		// ob3 에서는 c라는 변수 선언되어 있지 않음
		// 그런데 c에 접근하라니까 에러남!
		//-- 상위 객체는 하위 객체의 멤버에 접근하는 것이 불가능하다.

		//ob4 = ob3;
		//--==> 에러 발생 (컴파일 에러) 
		//		error: incompatible types: SuperTest118 cannot be converted to SubTest118
		//-- 상위 객체는 하위 객체에 담을 수(참조할 수) 없다.

		//ob4 = (SubTest118)ob3;
		//--==> 에러 발생 (런타임 에러) Exception in thread "main" java.lang.ClassCastException: 
		//								SuperTest118 cannot be cast to SubTest118
		//-- 작성된 구문의 문법적인 구조만 봤을 때
		//	 다운 캐스팅이 이루어지는 상황이다.
		//	 하지만, 정상적인 캐스팅이 이루어지지 않는다.
		//	 현재 SubTest118 객체에 대해 메모리 할당이 이루어지지 않은 상태이기 때문에
		//	 다운 캐스팅은 불가능한 것이다.

		// 그럼 자식 객체 인스턴스 생성해놓으면 다운캐스팅 가능??
		// SuperTest118 ob3 = new SuperTest118();
		// SubTest118 ob4;
		//		==> ob4 자식 객체 미리 생성 해놓으면 
		// ob4 = (SubTest118)ob3; 
		//		==> 이거 가능?
		// NO!!! ob3와 ob4와는 연결고리 없음
		// 부모클래스를 통해서 자식클래스가 메모리 할당받은 거 아님
		//	자식클래스를 만들면 자식클래스를 통해서 부모클래스 생성하지 않아도
		//	자동으로 메모리 생성이 되는거!

		// 자식타입의 인스턴스가 생성되는 거면 부모것도 메모리에 퍼올려지는 것
		// 자식의 생성자가 부모의 생성자 호출하니까!
		// SubTest118 ob1 = new SubTest118();
		// 이 구문 하나로, 자식클래스 & 부모클래스 다 메모리에 올라가는 것
		// BUT, 부모클래스의 인스턴스 생성구문에서
		//		자식 클래스 생성자 호출하거나, 자식 인스턴스 메모리에 올리거나 하지 않음
		
	}
}

/*
○ 업 캐스팅, 다운 캐스팅이 정상적으로 이루어지는 경우 --------------------------------------

	1. 하위 객체 생성;		//-- check~!!!!!!!!!!!
	2. 상위 = 하위;			// 업 캐스팅. 정상.
	3. 하위 = 상위;			// 에러 발생.		=> 상위 변수 선언만 한 상태
	4. 하위 = (하위)상위;	// 다운 캐스팅. 정상.


○ 업 캐스팅, 다운 캐스팅이 정상적으로 이루어지지 않는 경우 ---------------------------------

	1. 상위 객체 생성;		//-- check~!!!!!!!!!!!
	2. 하위 = 상위;			// 에러 발생.		=> 하위 변수 선언만 한 상태
	3. 하위 = (하위)상위;	// 다운 캐스팅. 런타임 에러 발생


※ 업 캐스팅은 항상 가능. 다운 캐스팅은 경우에 따라 가능

KEY: 생성된 객체가 하위 객체냐, 상위 객체냐에 따라서
*/

/*   ********************************
상위 = 하위;			//-- ok
상위 ob = new 하위();	//-- ok
********************************    */   